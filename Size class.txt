Rules of Thumb
The following guidelines will help you succeed with Auto Layout. There are undoubtedly a number of legitimate exceptions for each of these rules. However, if you decide to veer from them, pause and carefully consider your approach before proceeding.

Never specify a view’s geometry using its frame, bounds, or center properties.

Use stack views wherever possible

Stack views manage the layout of their content, greatly simplifying the constraint logic needed for the rest of the layout. Resort to custom constraints only when a stack view doesn’t provide the behavior you need.

Create constraints between a view and its nearest neighbor.

If you have two buttons next to each other, constrain the leading edge of the second button to the trailing edge of the first. The second button generally should not have a constraint that reaches across the first button to the view’s edge.

Avoid giving views a fixed height or width.

The whole point of Auto Layout is to dynamically respond to changes. Setting a fixed size removes the view’s ability to adapt. However, you may want to set a minimum or maximum size for the view.

If you are having trouble setting constraints, try using the Pin and Align tools. Although these tools can be somewhat slower than Control-dragging, they do let you verify the exact values and items involved before creating the constraint. This extra sanity check can be helpful, especially when you are first starting out.

Be careful when automatically updating an item’s frame. If the item does not have enough constraints to fully specify its size and position, the update’s behavior is undefined. Views often disappear either because their height or width gets set to zero or because they are accidentally positioned off screen.

You can always try to update an item’s frame, and then undo the change, if necessary.

Make sure all the views in your layout have meaningful names. This makes it much easier to identify your views when using the tools.

The system automatically names labels and buttons based on their text or title. For other views, you may need to set an Xcode specific label in the Identity inspector (or by double-clicking and editing the view’s name in the document outline).

Always use leading and trailing constraints instead of right and left.

You can always adjust how the view interprets its leading and trailing edges using its semanticContentAttribute property (iOS) or its userInterfaceLayoutDirection property (OS X).

In iOS, when constraining an item to the edge of the view controller’s root view, use the following constraints:

Horizontal constraints. For most controls, use a zero-point constraint to the layout margins. The system automatically provides the correct spacing based on what the device is and how the app presents the view controller.

For text objects that fill the root view from margin to margin, use the readable content guides instead of the layout margins.

For items that need to fill the root view from edge to edge (for example, background images), use the view’s leading and trailing edges.

Vertical constraints. If the view extends under the bars, use the top and bottom margins. This is particularly common for scroll views, allowing the content to scroll under the bars. Note, however, that you may need to modify the scroll view’s contentInset and scrollIndicatorInsets properties to correctly set the content’s initial position.

If the view does not extend under the bars, constrain the view to the top and bottom layout guides instead.

When programmatically instantiating views, be sure to set their translatesAutoresizingMaskIntoConstraints property to NO. By default, the system automatically creates a set of constraints based on the view’s frame and its autoresizing mask. When you add your own constraints, they inevitably conflict with the autogenerated constraints. This creates an unsatisfiable layout.

Be aware that OS X and iOS calculate their layouts differently.

In OS X, Auto Layout can modify both the contents of a window and the window’s size.

In iOS, the system provides the size and layout of the scene. Auto Layout can modify only the contents of the scene.

These differences seem relatively minor, but they can have a profound impact on how you design your layout, especially on how you use priorities.
Ankit issue branches
Second issue branches
